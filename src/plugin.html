<plugin>

    <div class="leaflet-top leaflet-left">
        <button class="button-closer" id="closebutton" >&#x2715</button>
    </div>
    <div class="leaflet-top leaflet-left" style="font-size: 15pt" id="introtext">
        <p>Click on a location to open a skewT...</p>
    </div>


    <!-- load dependent scripts -->
    <script src=src/skewT.js></script>
    <script src=src/wind_barbs.js></script>
    <script src=src/Sample_data.json.js></script>

	<script>

    import picker from '@windy/picker'
    import utils from '@windy/utils'
    import store from '@windy/store'
    import map from '@windy/map'
    import pluginDataLoader from '@windy/pluginDataLoader'



	/************************************************************************
	* SkewT.js
	*
	* A windy plugin written by John C. Kealy.
    *
	* Based on a stripped-down version of the https://www.tephigrams.org code.
    *
    * Email any queries to me at johnckealy@gmail.com.
    *
	* Dec 2018
	*
	*************************************************************************/


    // Set global variables for window size. These will
    // need to optimised later.
    function set_dimensions() {
        window.w = 0.8*window.innerHeight;
        window.h = 0.7*window.innerHeight;

        window.barbsw = 0.08*w;
        window.barbsh = h;

        window.x_offset = 50;
        window.y_offset = 90;

        window.PickerOn = false;
    }
    set_dimensions();
    document.onresize = set_dimensions();
    
    const options  = {
        key: 'psfAt10AZ7JJCoM3kz0U1ytDhTiLNJN3',
        plugin: 'windy-plugin-skewt'
    }

    const load = pluginDataLoader( options )


    // Run the plugin based on invoking the picker
 	const activate_SkewT = latLon => {
        let { lat, lon } = picker.getParams()
        window.PickerOn = true;
        set_dimensions();
        var introtext = document.getElementById('introtext')
        introtext.style.visibility = "hidden";

        // There's a bug in the API here. If you select a different
        // model, the old model stays there until you do something else
        // console.log(store.get('product'))

        const dataOptions = {
            model: store.get('product'),
            lat: lat,
            lon: lon
        }

        if (store.get('product')=='ecmwf') {
            dataOptions.model = 'gfs'
            console.log("ECMWF isn't currently available; using GFS")
        }


        // load up a an array with a timeseries of the surface
        // pressure using the 'forecast' API call.
        load('forecast', dataOptions).then( ({data}) => {
     	    window.Pressure = []
			for (const key of Object.keys(data.data)) {
				for (var i = 0;i<data.data[key].length;i++) {
			    	Pressure.push(data.data[key][i].pressure/100)
				}
			}
        });


        //Load point forecast for lat, lon.
		load('airData', dataOptions ).then( ({data}) => {

            var current_timestamp = store.get('timestamp');

            var tidx = gettimestamp(current_timestamp, data.data.hours);

	        var Pascent = [Pressure[tidx], 950, 925, 900, 850, 800, 700, 600, 500, 400, 300, 200, 150];
	        var Tdascent = get_data(data, 'dewpoint', tidx);
	        var Tascent = get_data(data, 'temp', tidx);


	        for (var z=0;z<Tdascent.length;z++) {
	              Tascent[z] = Math.round(100*(Tascent[z] - 273.15))/100;
	              Tdascent[z] = Math.round(100*(Tdascent[z] - 273.15))/100;
	        };
	        var U = get_data(data, 'wind_u', tidx);
	        var V = get_data(data, 'wind_v', tidx);

		    // draw the skewT and the windbarbs. These functions are stored
	        // in dedicated files.
	        draw_skewT(Pascent, Tascent, Tdascent);
	        cbarbs(Pascent, Tascent,  U, V, current_timestamp, dataOptions);

		});
	}

    // As the picker appears or moves, draw the SkewT at the new latlon point
    picker.on('pickerOpened', activate_SkewT)
    picker.on('pickerMoved', activate_SkewT )
    store.on('timestamp', function () { if (PickerOn) {activate_SkewT(); }})


    // On drag, dont redraw the skewT but do move the window to follow the drag
	const ondrag = () => {
 		translate_obj('skewTd3');
	};
    map.on('drag', ondrag);

    // close the skewT when the picker is closed
    const close_skewT = () => {
		d3.select("#skewTbox").remove();
        window.PickerOn = false;
        var close_button = document.getElementById('closebutton')
        close_button.style.visibility = "hidden";
    }
    picker.on('pickerClosed', close_skewT )


	function draw_skewT(Pascent, Tascent, Tdascent) {
        // When invoked, draw the skewT and also update the position if necessary
        cskewT(Pascent, Tascent, Tdascent)
 		translate_obj()
	};


	function translate_obj() {
        /* This function allows the skewT window to move with the map instead of
        being stuck at its original coordinates. It finds and parses the map offset
        specified by the "leaflet-map-pane", replaces each (x,y) number by its additive
        inverse, and applies that position to the skewT popup. */

 		var GetTransform= document.getElementsByClassName("leaflet-map-pane")[0]
        var Attrtxt = GetTransform.getAttribute("style")
 		var NUMERIC_REGEXP = /[-]{0,1}[\d]*[\.]{0,1}[\d]+/g;
        var Xpx = -1*Number(Attrtxt.match(NUMERIC_REGEXP)[1]) + x_offset
        var Ypx = -1*Number(Attrtxt.match(NUMERIC_REGEXP)[2]) + y_offset
        var Zpx = Number(Attrtxt.match(NUMERIC_REGEXP)[3])
        var translation = "translate3d("+Xpx+"px, "+Ypx+"px,  "+Zpx+"px)";
        var S = document.getElementById('skewTbox')
        if ( S != null) {
		    S.setAttribute("style", "transform: "+translation)
		};
	};


	function closest_latlon(Points, plon, plat) {
		// Computes the location in the sample data of the closest point
		// to that requested by the picker.
		var chosen = 0;
		var miin = 99999;
	    for (var i=0; i<Points.length; i++) {
	        var Gridlon = Points[i].Position.Longitude
	        var Gridlat = Points[i].Position.Latitude
	        var d2 = Math.pow(Math.abs(Gridlon-plon), 2) + Math.pow(Math.abs(Gridlat-plat), 2);
	        var d = Math.sqrt(d2);
	        if (d < miin) {
			    chosen = i;
			    miin = d;
			}
	    };
	    return chosen
	}

    function gettimestamp(current_timestamp, h) {
        var i=0;
        var minDiff = 99999999999;
        var tidx;
        for (i in h) {
            var m=Math.abs(current_timestamp-h[i])
            if (m<minDiff) {
                minDiff=m
                tidx=i
            };
        };
        return tidx;
    };


    function get_data(data, field, tidx) {

        var ascent = new Array(13);
        ascent[0] = data.data[field+'-surface'][tidx];
        ascent[1] = data.data[field+'-950h'][tidx];
        ascent[2] = data.data[field+'-925h'][tidx];
        ascent[3] = data.data[field+'-900h'][tidx];
        ascent[4] = data.data[field+'-850h'][tidx];
        ascent[5] = data.data[field+'-800h'][tidx];
        ascent[6] = data.data[field+'-700h'][tidx];
        ascent[7] = data.data[field+'-600h'][tidx];
        ascent[8] = data.data[field+'-500h'][tidx];
        ascent[9] = data.data[field+'-400h'][tidx];
        ascent[10] = data.data[field+'-300h'][tidx];
        ascent[11] = data.data[field+'-200h'][tidx];
        ascent[12] = data.data[field+'-150h'][tidx];

        return ascent
    }

	</script>

</plugin>
